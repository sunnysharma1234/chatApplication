{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  HeadersAdapter: null,\n  ReadonlyHeadersError: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  HeadersAdapter: function () {\n    return HeadersAdapter;\n  },\n  ReadonlyHeadersError: function () {\n    return ReadonlyHeadersError;\n  }\n});\nconst _reflect = require(\"./reflect\");\nclass ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\"Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers\");\n  }\n  static callable() {\n    throw new ReadonlyHeadersError();\n  }\n}\nclass HeadersAdapter extends Headers {\n  constructor(headers) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super();\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === \"symbol\") {\n          return _reflect.ReflectAdapter.get(target, prop, receiver);\n        }\n        const lowercased = prop.toLowerCase();\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(o => o.toLowerCase() === lowercased);\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === \"undefined\") return;\n        // If the original casing exists, return the value.\n        return _reflect.ReflectAdapter.get(target, original, receiver);\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === \"symbol\") {\n          return _reflect.ReflectAdapter.set(target, prop, value, receiver);\n        }\n        const lowercased = prop.toLowerCase();\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(o => o.toLowerCase() === lowercased);\n        // If the original casing doesn't exist, use the prop as the key.\n        return _reflect.ReflectAdapter.set(target, original ?? prop, value, receiver);\n      },\n      has(target, prop) {\n        if (typeof prop === \"symbol\") return _reflect.ReflectAdapter.has(target, prop);\n        const lowercased = prop.toLowerCase();\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(o => o.toLowerCase() === lowercased);\n        // If the original casing doesn't exist, return false.\n        if (typeof original === \"undefined\") return false;\n        // If the original casing exists, return true.\n        return _reflect.ReflectAdapter.has(target, original);\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === \"symbol\") return _reflect.ReflectAdapter.deleteProperty(target, prop);\n        const lowercased = prop.toLowerCase();\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(o => o.toLowerCase() === lowercased);\n        // If the original casing doesn't exist, return true.\n        if (typeof original === \"undefined\") return true;\n        // If the original casing exists, delete the property.\n        return _reflect.ReflectAdapter.deleteProperty(target, original);\n      }\n    });\n  }\n  /**\n  * Seals a Headers instance to prevent modification by throwing an error when\n  * any mutating method is called.\n  */\n  static seal(headers) {\n    return new Proxy(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case \"append\":\n          case \"delete\":\n          case \"set\":\n            return ReadonlyHeadersError.callable;\n          default:\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n        }\n      }\n    });\n  }\n  /**\n  * Merges a header value into a string. This stores multiple values as an\n  * array, so we need to merge them into a string.\n  *\n  * @param value a header value\n  * @returns a merged header value (a string)\n  */\n  merge(value) {\n    if (Array.isArray(value)) return value.join(\", \");\n    return value;\n  }\n  /**\n  * Creates a Headers instance from a plain object or a Headers instance.\n  *\n  * @param headers a plain object or a Headers instance\n  * @returns a headers instance\n  */\n  static from(headers) {\n    if (headers instanceof Headers) return headers;\n    return new HeadersAdapter(headers);\n  }\n  append(name, value) {\n    const existing = this.headers[name];\n    if (typeof existing === \"string\") {\n      this.headers[name] = [existing, value];\n    } else if (Array.isArray(existing)) {\n      existing.push(value);\n    } else {\n      this.headers[name] = value;\n    }\n  }\n  delete(name) {\n    delete this.headers[name];\n  }\n  get(name) {\n    const value = this.headers[name];\n    if (typeof value !== \"undefined\") return this.merge(value);\n    return null;\n  }\n  has(name) {\n    return typeof this.headers[name] !== \"undefined\";\n  }\n  set(name, value) {\n    this.headers[name] = value;\n  }\n  forEach(callbackfn, thisArg) {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this);\n    }\n  }\n  *entries() {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase();\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name);\n      yield [name, value];\n    }\n  }\n  *keys() {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase();\n      yield name;\n    }\n  }\n  *values() {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key);\n      yield value;\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n}","map":{"version":3,"names":["HeadersAdapter","ReadonlyHeadersError","Error","constructor","callable","Headers","headers","Proxy","get","target","prop","receiver","_reflect","ReflectAdapter","lowercased","toLowerCase","original","Object","keys","find","o","set","value","has","deleteProperty","seal","merge","Array","isArray","join","from","append","name","existing","push","delete","forEach","callbackfn","thisArg","entries","call","key","values","Symbol","iterator"],"sources":["../../../../../src/server/web/spec-extension/adapters/headers.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}