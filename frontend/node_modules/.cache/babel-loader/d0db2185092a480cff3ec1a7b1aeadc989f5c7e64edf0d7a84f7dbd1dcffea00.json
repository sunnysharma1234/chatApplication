{"ast":null,"code":"/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */ // Once postpone is in stable we should switch to importing the postpone export directly\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  Postpone: null,\n  createPostponedAbortSignal: null,\n  createPrerenderState: null,\n  formatDynamicAPIAccesses: null,\n  markCurrentScopeAsDynamic: null,\n  trackDynamicDataAccessed: null,\n  trackDynamicFetch: null,\n  usedDynamicAPIs: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  Postpone: function () {\n    return Postpone;\n  },\n  createPostponedAbortSignal: function () {\n    return createPostponedAbortSignal;\n  },\n  createPrerenderState: function () {\n    return createPrerenderState;\n  },\n  formatDynamicAPIAccesses: function () {\n    return formatDynamicAPIAccesses;\n  },\n  markCurrentScopeAsDynamic: function () {\n    return markCurrentScopeAsDynamic;\n  },\n  trackDynamicDataAccessed: function () {\n    return trackDynamicDataAccessed;\n  },\n  trackDynamicFetch: function () {\n    return trackDynamicFetch;\n  },\n  usedDynamicAPIs: function () {\n    return usedDynamicAPIs;\n  }\n});\nconst _react = /*#__PURE__*/_interop_require_default(require(\"react\"));\nconst _hooksservercontext = require(\"../../client/components/hooks-server-context\");\nconst _staticgenerationbailout = require(\"../../client/components/static-generation-bailout\");\nconst _url = require(\"../../lib/url\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nconst hasPostpone = typeof _react.default.unstable_postpone === \"function\";\nfunction createPrerenderState(isDebugSkeleton) {\n  return {\n    isDebugSkeleton,\n    dynamicAccesses: []\n  };\n}\nfunction markCurrentScopeAsDynamic(store, expression) {\n  const pathname = (0, _url.getPathname)(store.urlPathname);\n  if (store.isUnstableCacheCallback) {\n    // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n    // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n    // forbidden inside a cache scope.\n    return;\n  } else if (store.dynamicShouldError) {\n    throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${pathname} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);\n  } else if (\n  // We are in a prerender (PPR enabled, during build)\n  store.prerenderState) {\n    // We track that we had a dynamic scope that postponed.\n    // This will be used by the renderer to decide whether\n    // the prerender requires a resume\n    postponeWithTracking(store.prerenderState, expression, pathname);\n  } else {\n    store.revalidate = 0;\n    if (store.isStaticGeneration) {\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new _hooksservercontext.DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);\n      store.dynamicUsageDescription = expression;\n      store.dynamicUsageStack = err.stack;\n      throw err;\n    }\n  }\n}\nfunction trackDynamicDataAccessed(store, expression) {\n  const pathname = (0, _url.getPathname)(store.urlPathname);\n  if (store.isUnstableCacheCallback) {\n    throw new Error(`Route ${pathname} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"${expression}\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`);\n  } else if (store.dynamicShouldError) {\n    throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${pathname} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);\n  } else if (\n  // We are in a prerender (PPR enabled, during build)\n  store.prerenderState) {\n    // We track that we had a dynamic scope that postponed.\n    // This will be used by the renderer to decide whether\n    // the prerender requires a resume\n    postponeWithTracking(store.prerenderState, expression, pathname);\n  } else {\n    store.revalidate = 0;\n    if (store.isStaticGeneration) {\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new _hooksservercontext.DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);\n      store.dynamicUsageDescription = expression;\n      store.dynamicUsageStack = err.stack;\n      throw err;\n    }\n  }\n}\nfunction Postpone(_ref) {\n  let {\n    reason,\n    prerenderState,\n    pathname\n  } = _ref;\n  postponeWithTracking(prerenderState, reason, pathname);\n}\nfunction trackDynamicFetch(store, expression) {\n  if (store.prerenderState) {\n    postponeWithTracking(store.prerenderState, expression, store.urlPathname);\n  }\n}\nfunction postponeWithTracking(prerenderState, expression, pathname) {\n  assertPostpone();\n  const reason = `Route ${pathname} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;\n  prerenderState.dynamicAccesses.push({\n    // When we aren't debugging, we don't need to create another error for the\n    // stack trace.\n    stack: prerenderState.isDebugSkeleton ? new Error().stack : undefined,\n    expression\n  });\n  _react.default.unstable_postpone(reason);\n}\nfunction usedDynamicAPIs(prerenderState) {\n  return prerenderState.dynamicAccesses.length > 0;\n}\nfunction formatDynamicAPIAccesses(prerenderState) {\n  return prerenderState.dynamicAccesses.filter(access => typeof access.stack === \"string\" && access.stack.length > 0).map(_ref2 => {\n    let {\n      expression,\n      stack\n    } = _ref2;\n    stack = stack.split(\"\\n\") // Remove the \"Error: \" prefix from the first line of the stack trace as\n    // well as the first 4 lines of the stack trace which is the distance\n    // from the user code and the `new Error().stack` call.\n    .slice(4).filter(line => {\n      // Exclude Next.js internals from the stack trace.\n      if (line.includes(\"node_modules/next/\")) {\n        return false;\n      }\n      // Exclude anonymous functions from the stack trace.\n      if (line.includes(\" (<anonymous>)\")) {\n        return false;\n      }\n      // Exclude Node.js internals from the stack trace.\n      if (line.includes(\" (node:\")) {\n        return false;\n      }\n      return true;\n    }).join(\"\\n\");\n    return `Dynamic API Usage Debug - ${expression}:\\n${stack}`;\n  });\n}\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`);\n  }\n}\nfunction createPostponedAbortSignal(reason) {\n  assertPostpone();\n  const controller = new AbortController();\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    _react.default.unstable_postpone(reason);\n  } catch (x) {\n    controller.abort(x);\n  }\n  return controller.signal;\n}","map":{"version":3,"names":["Postpone","createPostponedAbortSignal","createPrerenderState","formatDynamicAPIAccesses","markCurrentScopeAsDynamic","trackDynamicDataAccessed","trackDynamicFetch","usedDynamicAPIs","hasPostpone","_react","default","unstable_postpone","isDebugSkeleton","dynamicAccesses","store","expression","pathname","_url","getPathname","urlPathname","isUnstableCacheCallback","dynamicShouldError","_staticgenerationbailout","StaticGenBailoutError","prerenderState","postponeWithTracking","revalidate","isStaticGeneration","err","_hooksservercontext","DynamicServerError","dynamicUsageDescription","dynamicUsageStack","stack","Error","_ref","reason","assertPostpone","push","undefined","length","filter","access","map","_ref2","split","slice","line","includes","join","controller","AbortController","x","abort","signal"],"sources":["../../../src/server/app-render/dynamic-rendering.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}